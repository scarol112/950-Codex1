head	1.3;
access;
symbols;
locks
	scarol:1.3; strict;
comment	@# @;


1.3
date	2025.10.20.20.15.20;	author scarol;	state Exp;
branches;
next	1.2;

1.2
date	2025.10.20.12.33.14;	author scarol;	state Exp;
branches;
next	1.1;

1.1
date	2025.10.19.19.29.56;	author scarol;	state Exp;
branches;
next	;


desc
@Vimdiff wrapper for recent RCS revisions
@


1.3
log
@added RCS headers
@
text
@#!/usr/bin/env bash
# $Source$
# $Date$
# $Revision$
# $State$

set -euo pipefail

usage() {
    echo "Usage: $0 [-w] <file> [revision [revision]]" >&2
    exit 1
}

compare_working=false
while getopts ":w" opt; do
    case "$opt" in
        w) compare_working=true ;;
        *) usage ;;
    esac
done
shift $((OPTIND - 1))

if [ $# -lt 1 ]; then
    usage
fi

target_file=$1
shift
rev_args=("$@@")
rev_count=${#rev_args[@@]}

if ! rlog_output=$(rlog "$target_file" 2>/dev/null); then
    echo "Failed to read RCS history for $target_file" >&2
    exit 1
fi

mapfile -t revisions < <(printf '%s\n' "$rlog_output" | awk '/^revision / { print $2 }')

if [ ${#revisions[@@]} -eq 0 ]; then
    echo "No revisions found in RCS history for $target_file" >&2
    exit 1
fi

find_revision_index() {
    local search=$1
    local idx
    for idx in "${!revisions[@@]}"; do
        if [ "${revisions[$idx]}" = "$search" ]; then
            printf '%s\n' "$idx"
            return 0
        fi
    done
    return 1
}

ensure_revision_exists() {
    local rev=$1
    if ! find_revision_index "$rev" >/dev/null; then
        echo "Revision '$rev' not found for $target_file" >&2
        exit 1
    fi
}

tmpdir=$(mktemp -d)
trap 'rm -rf "$tmpdir"' EXIT

diff_paths=()

if $compare_working; then
    if [ "$rev_count" -gt 1 ]; then
        echo "Option -w accepts at most one revision argument" >&2
        exit 1
    fi
    if [ "$rev_count" -eq 1 ]; then
        rev=${rev_args[0]}
        ensure_revision_exists "$rev"
    else
        rev=${revisions[0]}
    fi
    rev_file="$tmpdir/${target_file##*/}.$rev"
    co -p -r"$rev" "$target_file" >"$rev_file"
    diff_paths=("$rev_file" "$target_file")
else
    case "$rev_count" in
        0)
            if [ ${#revisions[@@]} -lt 2 ]; then
                echo "Need at least two revisions in RCS history for $target_file" >&2
                exit 1
            fi
            rev_a=${revisions[1]}
            rev_b=${revisions[0]}
            ;;
        1)
            rev_b=${rev_args[0]}
            rev_index=$(find_revision_index "$rev_b") || {
                echo "Revision '$rev_b' not found for $target_file" >&2
                exit 1
            }
            if [ $((rev_index + 1)) -ge ${#revisions[@@]} ]; then
                echo "Revision '$rev_b' has no previous revision to compare against" >&2
                exit 1
            fi
            rev_a=${revisions[$((rev_index + 1))]}
            ;;
        *)
            rev_a=${rev_args[0]}
            rev_b=${rev_args[1]}
            ensure_revision_exists "$rev_a"
            ensure_revision_exists "$rev_b"
            ;;
    esac
    file_a="$tmpdir/${target_file##*/}.$rev_a"
    file_b="$tmpdir/${target_file##*/}.$rev_b"
    co -p -r"$rev_a" "$target_file" >"$file_a"
    co -p -r"$rev_b" "$target_file" >"$file_b"
    diff_paths=("$file_a" "$file_b")
fi

vimdiff "${diff_paths[@@]}"
@


1.2
log
@*** empty log message ***
@
text
@d2 5
@


1.1
log
@Add helper to diff last two revisions
@
text
@d5 1
a5 1
    echo "Usage: $0 <file>" >&2
d9 10
a18 1
if [ $# -ne 1 ]; then
d23 3
a31 1
# Collect revisions starting from the most recent within RCS history.
d34 2
a35 2
if [ ${#revisions[@@]} -lt 2 ]; then
    echo "Need at least two revisions in RCS history for $target_file" >&2
d39 19
a57 2
new_rev=${revisions[0]}
old_rev=${revisions[1]}
d62 1
a62 2
new_file="$tmpdir/${target_file##*/}.$new_rev"
old_file="$tmpdir/${target_file##*/}.$old_rev"
d64 49
a112 2
co -p -r"$new_rev" "$target_file" >"$new_file"
co -p -r"$old_rev" "$target_file" >"$old_file"
d114 1
a114 1
vimdiff "$old_file" "$new_file"
@
