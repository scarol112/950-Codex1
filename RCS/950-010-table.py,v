head	1.11;
access;
symbols;
locks
	scarol:1.11; strict;
comment	@# @;


1.11
date	2025.10.21.18.36.32;	author scarol;	state Exp;
branches;
next	1.10;

1.10
date	2025.10.21.18.24.10;	author scarol;	state Exp;
branches;
next	1.9;

1.9
date	2025.10.21.18.02.21;	author scarol;	state Exp;
branches;
next	1.8;

1.8
date	2025.10.20.20.15.20;	author scarol;	state Exp;
branches;
next	1.7;

1.7
date	2025.10.20.12.02.02;	author scarol;	state Exp;
branches;
next	1.6;

1.6
date	2025.10.20.01.26.08;	author scarol;	state Exp;
branches;
next	1.5;

1.5
date	2025.10.20.01.13.28;	author scarol;	state Exp;
branches;
next	1.4;

1.4
date	2025.10.20.00.52.39;	author scarol;	state Exp;
branches;
next	1.3;

1.3
date	2025.10.20.00.21.50;	author scarol;	state Exp;
branches;
next	1.2;

1.2
date	2025.10.19.19.15.17;	author scarol;	state Exp;
branches;
next	1.1;

1.1
date	2025.10.19.19.11.14;	author scarol;	state Exp;
branches;
next	;


desc
@ASCII table script
@


1.11
log
@*** empty log message ***
@
text
@#!/usr/bin/env python3
# $Source: /srv/950-Codex1/RCS/950-010-table.py,v $
# $Date: 2025/10/21 18:24:10 $
# $Revision: 1.10 $
# $State: Exp $

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Iterable, List, Sequence

ALLOWED_DELIMITERS = {" ", "-", "/", "|", ","}
STYLE_DEFINITIONS: dict[str, dict[str, object]] = {
    "t": {
        "vertical": "|",
        "top": ("+", "+", "+", "-"),
        "middle_thin": ("+", "+", "+", "-"),
        "middle_thick": ("+", "+", "+", "="),
        "bottom_thin": ("+", "+", "+", "-"),
        "bottom_thick": ("+", "+", "+", "="),
    },
    "g": {
        "vertical": "│",
        "top": ("┌", "┬", "┐", "─"),
        "middle_thin": ("├", "┼", "┤", "─"),
        "middle_thick": ("╞", "╪", "╡", "═"),
        "bottom_thin": ("└", "┴", "┘", "─"),
        "bottom_thick": ("╘", "╧", "╛", "═"),
    },
}


def parse_border_interval(value: str) -> int | str:
    if value.lower() == "x":
        return "x"
    try:
        parsed = int(value)
    except ValueError as exc:
        raise argparse.ArgumentTypeError(
            "thick border interval must be a non-negative integer or 'x'"
        ) from exc
    if parsed < 0:
        raise argparse.ArgumentTypeError(
            "thick border interval must be a non-negative integer or 'x'"
        )
    return parsed


def parse_style(value: str) -> str:
    key = value.lower()
    if key not in STYLE_DEFINITIONS:
        raise argparse.ArgumentTypeError("style must be 't' (text) or 'g' (graphics)")
    return key


def detect_style(lines: Sequence[str]) -> str:
    for style_key, config in STYLE_DEFINITIONS.items():
        vertical = config["vertical"]
        for raw_line in lines:
            line = raw_line.rstrip("\n")
            if line and line.startswith(vertical) and line.endswith(vertical):
                return style_key
    return "t"


def parse_rows(
    lines: Iterable[str],
    *,
    skip_empty: bool = True,
    delimiter: str = "|",
) -> List[List[str]]:
    rows: List[List[str]] = []
    for raw_line in lines:
        line = raw_line.rstrip("\n")
        if skip_empty and not line.strip():
            continue
        cells = [cell.strip() for cell in line.split(delimiter)]
        rows.append(cells)
    if not rows:
        raise ValueError("no rows found in the input")
    return rows


def normalise_rows(rows: Sequence[List[str]]) -> List[List[str]]:
    max_columns = max(len(row) for row in rows)
    return [row + [""] * (max_columns - len(row)) for row in rows]


def transpose_rows(rows: Sequence[Sequence[str]]) -> List[List[str]]:
    return [list(column) for column in zip(*rows)]


def column_widths(rows: Sequence[Sequence[str]]) -> List[int]:
    widths = [0] * len(rows[0])
    for row in rows:
        for idx, cell in enumerate(row):
            widths[idx] = max(widths[idx], len(cell))
    return widths


def extract_table_rows(
    lines: Sequence[str],
    *,
    style: str | None = None,
) -> List[List[str]]:
    style_to_use = style or detect_style(lines)
    vertical = STYLE_DEFINITIONS[style_to_use]["vertical"]
    rows: List[List[str]] = []
    for raw_line in lines:
        line = raw_line.rstrip("\n")
        if not line:
            continue
        if not (line.startswith(vertical) and line.endswith(vertical)):
            continue
        inner = line[1:-1]
        cells = [cell.strip() for cell in inner.split(vertical)]
        rows.append(cells)
    if not rows:
        raise ValueError("no table rows found in the input")
    return rows


def render_table(
    rows: Sequence[Sequence[str]],
    *,
    thick_border_interval: int | str = 3,
    style: str = "t",
) -> str:
    widths = column_widths(rows)

    if thick_border_interval == "x":
        lines = []
        for row in rows:
            padded_cells = [
                cell.ljust(width) for cell, width in zip(row, widths)
            ]
            lines.append(" ".join(padded_cells).rstrip())
        return "\n".join(lines)

    assert isinstance(thick_border_interval, int)

    style_config = STYLE_DEFINITIONS[style]
    vertical = style_config["vertical"]

    def border(style: str) -> str:
        left, mid, right, fill = style_config[style]
        segments = [fill * (width + 2) for width in widths]
        return left + mid.join(segments) + right

    lines = [border("top")]
    total_rows = len(rows)
    for row_index, row in enumerate(rows, start=1):
        padded_cells = [
            f" {cell}{' ' * (width - len(cell))} " for cell, width in zip(row, widths)
        ]
        lines.append(vertical + vertical.join(padded_cells) + vertical)
        use_thick_border = (
            thick_border_interval > 0 and row_index % thick_border_interval == 0
        )
        is_last = row_index == total_rows
        if is_last:
            style = "bottom_thick" if use_thick_border else "bottom_thin"
        else:
            style = "middle_thick" if use_thick_border else "middle_thin"
        lines.append(border(style))
    return "\n".join(lines)


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        description="Render a delimited text file as an ASCII or Unicode table."
    )
    parser.add_argument(
        "input",
        help="Path to the input file. Use '-' to read from standard input.",
    )
    parser.add_argument(
        "-d",
        "--delimiter",
        default="|",
        choices=sorted(ALLOWED_DELIMITERS),
        help=(
            "Single-character column delimiter to parse the input. "
            "Allowed values: space, -, /, |, ,"
        ),
    )
    parser.add_argument(
        "-b",
        "--thick-border-interval",
        type=parse_border_interval,
        default=3,
        help=(
            "Insert a thicker separator every N data rows. "
            "Use 0 to disable thicker borders or 'x' to remove borders entirely "
            "(default: 3)."
        ),
    )
    parser.add_argument(
        "-t",
        "--transpose",
        action="store_true",
        help="Transpose the table before rendering, swapping rows with columns.",
    )
    parser.add_argument(
        "-s",
        "--style",
        type=parse_style,
        default=None,
        choices=sorted(STYLE_DEFINITIONS),
        help="Table style: 't' for text borders (default) or 'g' for Unicode graphics.",
    )
    parser.add_argument(
        "-r",
        "--remove",
        action="store_true",
        help="Remove borders/padding from a rendered table and output delimited data.",
    )
    return parser


def load_lines(input_path: str) -> Iterable[str]:
    if input_path == "-":
        return sys.stdin
    path = Path(input_path)
    if not path.exists():
        raise FileNotFoundError(f"input file '{input_path}' does not exist")
    return path.read_text(encoding="utf-8").splitlines(keepends=True)


def main(argv: list[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)
    try:
        lines_iterable = load_lines(args.input)
        lines = list(lines_iterable)
        if args.remove:
            table_rows = extract_table_rows(lines, style=args.style)
            output_lines = [args.delimiter.join(row) for row in table_rows]
            print("\n".join(output_lines))
            return 0
        rows = parse_rows(lines, delimiter=args.delimiter)
        normalised_rows = normalise_rows(rows)
        table_rows = transpose_rows(normalised_rows) if args.transpose else normalised_rows
        style_for_render = args.style or "t"
        table = render_table(
            table_rows,
            thick_border_interval=args.thick_border_interval,
            style=style_for_render,
        )
    except Exception as exc:  # noqa: BLE001
        parser.print_usage(file=sys.stderr)
        print(f"error: {exc}", file=sys.stderr)
        return 1
    print(table)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
@


1.10
log
@*** empty log message ***
@
text
@d3 2
a4 2
# $Date: 2025/10/21 18:02:21 $
# $Revision: 1.9 $
d15 1
a15 1
STYLE_DEFINITIONS = {
d58 10
d104 1
a104 1
    lines: Iterable[str],
d106 1
a106 1
    style: str,
d108 2
a109 1
    vertical = STYLE_DEFINITIONS[style]["vertical"]
d210 1
a210 1
        default="t",
d246 1
d250 1
a250 1
            style=args.style,
@


1.9
log
@*** empty log message ***
@
text
@d3 2
a4 2
# $Date: 2025/10/20 20:15:20 $
# $Revision: 1.8 $
d93 21
d203 6
d225 7
a231 1
        lines = load_lines(args.input)
d234 1
a234 3
        table_rows = (
            transpose_rows(normalised_rows) if args.transpose else normalised_rows
        )
@


1.8
log
@added RCS headers
@
text
@d2 4
a5 4
# $Source$
# $Date$
# $Revision$
# $State$
d15 18
d51 7
d94 4
a97 1
    rows: Sequence[Sequence[str]], *, thick_border_interval: int | str = 3
d112 3
d116 1
a116 8
        border_parts = {
            "top": ("┌", "┬", "┐", "─"),
            "middle_thin": ("├", "┼", "┤", "─"),
            "middle_thick": ("╞", "╪", "╡", "═"),
            "bottom_thin": ("└", "┴", "┘", "─"),
            "bottom_thick": ("╘", "╧", "╛", "═"),
        }
        left, mid, right, fill = border_parts[style]
d126 1
a126 1
        lines.append("│" + "│".join(padded_cells) + "│")
d141 1
a141 1
        description="Render a delimited text file as a Unicode box-drawing table."
d174 8
d207 1
@


1.7
log
@*** empty log message ***
@
text
@d2 5
@


1.6
log
@*** empty log message ***
@
text
@d51 4
d139 6
d164 3
d168 1
a168 1
            normalised_rows,
@


1.5
log
@*** empty log message ***
@
text
@d12 16
d60 1
a60 1
    rows: Sequence[Sequence[str]], *, thick_border_interval: int = 3
d64 11
d127 1
a127 1
        type=int,
d131 2
a132 1
            "Use 0 to disable thicker borders (default: 3)."
a153 1
        interval = max(args.thick_border_interval, 0)
d156 1
a156 1
            thick_border_interval=interval,
@


1.4
log
@*** empty log message ***
@
text
@d47 15
a61 3
    thin_border = "+" + "+".join("-" * (width + 2) for width in widths) + "+"
    thick_border = "+" + "+".join("=" * (width + 2) for width in widths) + "+"
    lines = [thin_border]
d66 1
a66 1
        lines.append("|" + "|".join(padded_cells) + "|")
d70 6
a75 1
        lines.append(thick_border if use_thick_border else thin_border)
d81 1
a81 1
        description="Render a delimited text file as an ASCII table."
@


1.3
log
@*** empty log message ***
@
text
@d43 3
a45 1
def render_table(rows: Sequence[Sequence[str]]) -> str:
d47 4
a50 3
    horizontal_border = "+" + "+".join("-" * (width + 2) for width in widths) + "+"
    lines = [horizontal_border]
    for row in rows:
d55 4
a58 1
        lines.append(horizontal_border)
d64 1
a64 1
        description="Render a pipe-delimited text file as an ASCII table."
d80 10
d109 5
a113 1
        table = render_table(normalised_rows)
@


1.2
log
@Refine table processing helpers
@
text
@d9 1
d11 7
a17 1
def parse_rows(lines: Iterable[str], *, skip_empty: bool = True) -> List[List[str]]:
d23 1
a23 1
        cells = [cell.strip() for cell in line.split("|")]
d64 10
d91 1
a91 1
        rows = parse_rows(lines)
@


1.1
log
@initial checkin
@
text
@d12 1
a12 1
    for line_no, raw_line in enumerate(lines, start=1):
d25 1
a25 5
    normalised: List[List[str]] = []
    for row in rows:
        padded = row + [""] * (max_columns - len(row))
        normalised.append(padded)
    return normalised
d38 2
a39 5

    def border(char: str = "-") -> str:
        return "+" + "+".join(char * (width + 2) for width in widths) + "+"

    lines = [border("-")]
d45 1
a45 1
        lines.append(border("-"))
@
